import lib/bool;

Desc : <l> -> Type l -> Type (S l)
  = \<l> I. Data (
      [False, True, Lift <S l> Bool, \x. ifDesc
      [False, True, Lift <S l> I, \x. [True, lift {Lift <S l> ()} []]] [False, True, Lift <S l> Bool, \x. ifDesc (
      [False, True, Type l, \x. [False, False, [False, True, Lift <S l> (lower x), \x. [True, lift {Lift <S l> ()} []]],
        [True, []]]]) [False, False, [True, []], [False, False, [True, lift {Lift <S l> ()} []],
        [True, lift {Lift <S l> ()} []]]] (lower (lower x))] (lower (lower x))]) [];

Var : <l> {I : Type l} -> I -> Desc I = \i. [True, lift i];
Arg : <l> {I : Type l} (A : Type l) -> (A -> Desc I) -> Desc I = \A K. [False, True, A, \x. K (lower x)];
Arg' : <l> {I : Type l} {A : Type l} -> (A -> Desc I) -> Desc I = \{I} {A} K. Arg {I} A K;
Ind : <l> {I : Type l} -> Desc I -> Desc I -> Desc I = \A B. [False, False, A, B];

(|:) : {I : Type} -> Desc I -> Desc I -> Desc I = \A B. Arg' (A <?> B);

SumDL : <l> {I : Type l} -> Desc I -> Desc I -> Desc I
  = \<l> A B. Arg (Lift <l> Bool) (\b. if (lower b) A B);

DescD : <l> -> Type l -> Desc (Lift <S l> ())
  = \<l> I. let var = Var (lift []);
      SumDL (Arg (Lift <S l> I) \_. var)
      (SumDL
        (Arg (Type l) (\A. Ind (Arg (Lift <S l> A) \_. var) var))
        (Ind var (Ind var var)));
