import lib/enum;
import lib/functor;
import lib/eq;

Sum <l> (A B : Type l) : Type l = (tag : Tag '[Left Right]) ** switch {Type l} tag [A, B];
Left <l> {A B : Type l} (x : A) : Sum A B = ('Left , x);
Right <l> {A B : Type l} (x : B) : Sum A B = ('Right , x);

indSum
  <l k> {A B : Type l}
  (P : Sum A B -> Type k)
  (left : (x : A) -> P (Left x))
  (right : (x : B) -> P (Right x))
  (sum : Sum A B) : P sum =
  switchD {'[Left Right]} (\tag. (data : switch {Type l} tag [A, B]) -> P (tag, data))
    sum._1
    [left, right]
    sum._2;

(+:) = Sum;

sum
  <l k> {A B : Type l} {R : Type k}
  (left : A -> R)
  (right : B -> R)
  (x : Sum A B) : R
  = indSum <l> <k> (\_. R) left right x;

swapSum <l> {A B : Type l} (x : Sum A B) : Sum B A = sum <l> <l> Right Left x;

mapSum <l> {X A B : Type l} (fn : A -> B) (x : Sum X A) : Sum X B
  = sum <l> <l> Left (\x. Right (fn x)) x;

instance functorSum : {X : Type} -> Functor (Sum X) = \{X}. MkFunctor (mapSum {X});

instance eqSum : {A B : Type} {{_ : Eq A}} {{_ : Eq B}} -> Eq (Sum A B)
  = \{A} {B}. MkEq {Sum A B} (\a b. sum {A} {B} (\x. sum (\y. eq x y) (\_. False) b) (\x. sum (\_. False) (\y. eq x y) b) a);
