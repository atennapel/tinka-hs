El : Desc -> Type -> Type
  = \D X. (elim El) X D;

map : (D : Desc) -> (A B : Type) -> (A -> B) -> El D A -> El D B
  = \D A B f. (elim Desc) (\D. El D A -> El D B)
      (\_. Unit)
      (\A K R p. (fst p, R (fst p) (snd p)))
      (\K R p. (f (fst p), R (snd p)))
      D;

SumDBody : Desc -> Desc -> Bool -> Desc
  = \A B. (elim Bool 1) (\_. Desc) A B;

SumD : Desc -> Desc -> Desc
  = \A B. Arg Bool (SumDBody A B);

NatD = SumD (Ind End) End;
Nat = Data NatD;
Z : Nat = Con NatD (False, Unit);
S : Nat -> Nat = \n. Con NatD (True, n, Unit);

indNat :
  (P : Nat -> Type)
  -> P Z
  -> ((m : Nat) -> P m -> P (S m))
  -> (n : Nat)
  -> P n
  = \P z s n. (elim Data) NatD P
      (\d. (elim Bool)
        (\b. (xs : El (SumDBody (Ind End) End b) Nat) ->
             ((elim All) (SumDBody (Ind End) End b) Nat P xs) ->
             P (Con NatD (b, xs)))
        (\xs h. s (fst xs) (fst h))
        (\_ _. z)
        (fst d)
        (snd d))
      n;

paraNat : (A : Type) -> Nat -> A -> (Nat -> A -> A) -> A
  = \A n z s. indNat (\_. A) z s n;

caseNat : (A : Type) -> Nat -> A -> (Nat -> A) -> A
  = \A n z s. paraNat A n z (\m _. s m);

cataNat : (A : Type) -> Nat -> A -> (A -> A) -> A
  = \A n z s. paraNat A n z (\_. s);

pred : Nat -> Nat = \n. caseNat Nat n Z (\x. x);
add : Nat -> Nat -> Nat = \a b. cataNat Nat a b S;
