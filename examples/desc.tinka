-- levitation
Desc = Data^ (
  Con (False, True, Bool, \x. (elim BoolDesc^) (Con (True, Unit)) (
  Con (False, True, Bool, \x. (elim BoolDesc^) (Con (False, True, Type, \x. Con (False, False, False, Lift (lower x), Con (True, Unit), Unit), Unit)) (
  Con (False, True, Bool, \x. (elim BoolDesc^) (Con (False, False, True, Con (True, Unit), Unit)) (
  Con (False, True, Type, \x. Con (False, False, True, Con (True, Unit), Unit), Unit)) (lower x), Unit)) (lower x), Unit)) (lower x), Unit));

End : Desc = Con (True, Unit);
Arg : (A : Type) -> (A -> Desc) -> Desc = \A K. Con (False, True, A, \x. K (lower x), Unit);
Ind : Desc -> Desc = \K. Con (False, False, True, K, Unit);
HInd : Type -> Desc -> Desc = \A K. Con (False, False, False, A, K, Unit);

El : Desc -> Type -> Type
  = \D X. (elim El) X D;

All : (D : Desc) -> (X : Type) -> (X -> Type) -> El D X -> Type
  = \D X P d. (elim All) D X P d;

SumDBody : Desc -> Desc -> Bool -> Desc
  = \A B. (elim Bool 1) (\_. Desc) A B;
SumD : Desc -> Desc -> Desc
  = \A B. Arg Bool (SumDBody A B);

DescD : Desc^ = SumD^ End^ (SumD^ (Arg^ Type (\A. HInd^ (Lift A) End^)) (SumD^ (Ind^ End^) (Arg^ Type (\_. Ind^ End^))));

indSumD :
  (A : Desc)
  (B : Desc)
  (P : Data (SumD A B) -> Type)
  (a : (d : El A (Data (SumD A B))) -> All A (Data (SumD A B)) P d -> P (Con (True, d)))
  (b : (d : El B (Data (SumD A B))) -> All B (Data (SumD A B)) P d -> P (Con (False, d)))
  (x : Data (SumD A B))
  -> P x
  = \A B P a b x. (elim Data) (SumD A B) P
      (\d hs. (elim Bool)
        (\b. (xs : El (SumDBody A B b) (Data (SumD A B))) -> All (SumD A B) (Data (SumD A B)) P (b, xs) -> P (Con (b, xs)))
        (\xs h. a xs h)
        (\xs h. b xs h)
        (fst d) (snd d) hs) x;

-- Nat
NatD = SumD (Ind End) End;
Nat = Data NatD;
Z : Nat = Con (False, Unit);
S : Nat -> Nat = \n. Con (True, n, Unit);

indNat :
  (P : Nat -> Type)
  -> P Z
  -> ((m : Nat) -> P m -> P (S m))
  -> (n : Nat)
  -> P n
  = \P z s n. indSumD (Ind End) End P
        (\xs h. s (fst xs) (fst h))
        (\_ _. z)
        n;

paraNat : (A : Type) -> Nat -> A -> (Nat -> A -> A) -> A
  = \A n z s. indNat (\_. A) z s n;

caseNat : (A : Type) -> Nat -> A -> (Nat -> A) -> A
  = \A n z s. paraNat A n z (\m _. s m);

cataNat : (A : Type) -> Nat -> A -> (A -> A) -> A
  = \A n z s. paraNat A n z (\_. s);

pred : Nat -> Nat = \n. caseNat Nat n Z (\x. x);
add : Nat -> Nat -> Nat = \a b. cataNat Nat a b S;

-- List
ListD : Type -> Desc = \A. SumD (Arg A (\_. Ind End)) End;
List : Type -> Type = \A. Data (ListD A);

Nil : (A : Type) -> List A = \A. Con (False, Unit);
Cons : (A : Type) -> A -> List A -> List A
  = \A hd tl. Con (True, hd, tl, Unit);

indList :
  (A : Type)
  (P : List A -> Type)
  -> P (Nil A)
  -> ((hd : A) (tl : List A) -> P tl -> P (Cons A hd tl))
  -> (l : List A)
  -> P l
  = \A P nil cons l. indSumD (Arg A (\_. Ind End)) End P
        (\xs h. cons (fst xs) (fst (snd xs)) (fst h))
        (\_ _. nil)
        l;

paraList : (A R : Type) -> List A -> R -> (A -> List A -> R -> R) -> R
  = \A R l nil cons. indList A (\_. R) nil cons l;

caseList : (A R : Type) -> List A -> R -> (A -> List A -> R) -> R
  = \A R l nil cons. paraList A R l nil (\hd tl _. cons hd tl);

cataList : (A R : Type) -> List A -> R -> (A -> R -> R) -> R
  = \A R l nil cons. paraList A R l nil (\hd _ tl. cons hd tl);

mapList : (A B : Type) -> (A -> B) -> List A -> List B
  = \A B fn l. cataList A (List B) l (Nil B) (\hd tl. Cons B (fn hd) tl);

appendList : (A : Type) -> List A -> List A -> List A
  = \A l1 l2. cataList A (List A) l1 l2 (\hd tl. Cons A hd tl);
