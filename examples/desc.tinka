El : Desc -> Type -> Type
  = \D X. (elim Desc 1) (\_. Type)
      UnitType
      (\A K R. (x : A) ** R x)
      (\K R. X ** R)
      D;

map : (D : Desc) -> (A B : Type) -> (A -> B) -> El D A -> El D B
  = \D A B f. (elim Desc) (\D. El D A -> El D B)
      (\_. Unit)
      (\A K R p. (fst p, R (fst p) (snd p)))
      (\K R p. (f (fst p), R (snd p)))
      D;

SumD : Desc -> Desc -> Desc
  = \A B. Arg Bool ((elim Bool 1) (\_. Desc) A B);

NatD = SumD (Ind End) End;
Nat = Data NatD;
Z : Nat = Con NatD (False, Unit);
S : Nat -> Nat = \n. Con NatD (True, n, Unit);

indNat :
  (P : Nat -> Type)
  -> P Z
  -> ((m : Nat) -> P m -> P (S m))
  -> (n : Nat)
  -> P n
  = \P z s n. (elim Data) NatD P (\R case ind y.
      (elim Bool) (\b. (rest : El ((elim Bool 1) (\_. Desc) (Ind End) End b) R) -> P (Con NatD (b, map ((elim Bool 1) (\_. Desc) (Ind End) End b) R (Data NatD) case rest)))
        (\p. s (case (fst p)) (ind (fst p)))
        (\_. z)
        (fst y) (snd y)) n;

paraNat : (A : Type) -> Nat -> A -> (Nat -> A -> A) -> A
  = \A n z s. indNat (\_. A) z s n;

caseNat : (A : Type) -> Nat -> A -> (Nat -> A) -> A
  = \A n z s. paraNat A n z (\m _. s m);

cataNat : (A : Type) -> Nat -> A -> (A -> A) -> A
  = \A n z s. paraNat A n z (\_. s);

pred : Nat -> Nat = \n. caseNat Nat n Z (\x. x);
add : Nat -> Nat -> Nat = \a b. cataNat Nat a b S;
