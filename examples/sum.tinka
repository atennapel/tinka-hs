if : (A : Type) -> Bool -> A -> A -> A
	= \A b t f. indBool (\_. A) t f b;

Sum : Type -> Type -> Type
	= \A B. (b : Bool) ** if^ Type b A B;

Left : (A B : Type) -> A -> Sum A B
  = \A B x. (True, x);

Right : (A B : Type) -> B -> Sum A B
  = \A B x. (False, x);

indSum :
	(A B : Type)
	(P : Sum A B -> Type)
	(left : (x : A) -> P (Left A B x))
	(right : (x : B) -> P (Right A B x))
	(sum : Sum A B)
	-> P sum
	= \A B P left right sum. _; 

sum :
	(A B R : Type)
	-> (A -> R)
	-> (B -> R)
	-> Sum A B
	-> R
	= \A B R left right x. indSum A B (\_. R) left right x;

swapSum : (A B : Type) -> Sum A B -> Sum B A
	= \A B. sum A B (Sum B A) (Right B A) (Left B A);

Functor : (Type -> Type) -> Type1
	= \F. (A B : Type) -> (A -> B) -> F A -> F B;

functorSum : (X : Type) -> Functor (Sum X)
	= \X A B fn s. sum X A (Sum X B) (Left X B) (\x. Right X B (fn x)) s;

-- derived Maybe
Maybe : Type -> Type = \A. Sum A UnitType;

Just : (A : Type) -> A -> Maybe A = \A x. Left A UnitType x;
Nothing : (A : Type) -> Maybe A = \A. Right A UnitType Unit;

indMaybe :
	(A : Type)
	(P : Maybe A -> Type)
	(just : (x : A) -> P (Just A x))
	(nothing : P (Nothing A))
	(m : Maybe A)
	-> P m
	= \A P just nothing m. indSum A UnitType P just (\_. nothing) m;

maybe : (A R : Type) -> (A -> R) -> R -> Maybe A -> R
	= \A R j n m. indMaybe A (\_. R) j n m;

functorMaybe : Functor Maybe
	= \A B fn s. maybe A (Maybe B) (\x. Just (fn x)) (Nothing B) s;
